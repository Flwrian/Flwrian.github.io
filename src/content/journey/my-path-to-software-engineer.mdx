---
title: "From High School to Software Engineer: My Path Through Code"
date: 2023-06-15
type: "transition"
description: "My journey from discovering computers at a technical high school in Lodève to becoming a software engineer focused on systems architecture and quality code."
skills:
  - "Software Development"
  - "Systems Architecture"
  - "Python"
  - "Java"
  - "Project Management"
---

## The Beginning: STI2D at Lycée Joseph Vallot

I wasn't completely new to computers when I started my Bac STI2D (Science and Technologies of Industry and Sustainable Development) at Lycée Joseph Vallot in Lodève. But it's where I learned the fundamentals that everything else would build on.

**What I really learned**:
- Boolean algebra and logic gates
- How computers actually work at a low level
- Mathematics applied to real systems
- Physics principles behind technology
- How to think systematically about problems

It wasn't just "learn to code" - it was "understand how systems work". That foundation matters more than I realized at the time.

## University: BUT Informatique in Montpellier

Three years at IUT Montpellier studying for my BUT Informatique (Bachelor of Technology in Computer Science). This is where I really became a software engineer.

**Technical Skills**:
- Software development (multiple paradigms)
- Systems programming and architecture
- Advanced mathematics (yes, even more math)
- Database design and management
- Network architecture
- Security fundamentals

**Soft Skills**:
- Communication and technical writing
- Project management
- Team collaboration
- Presenting technical concepts
- Balancing requirements and constraints

The mix of deep technical knowledge and professional skills was crucial. Code is only part of being a software engineer - you need to communicate, collaborate, and understand business context.

## What University Got Right

**1. Depth Over Breadth**

Rather than superficially covering every technology, we dove deep into fundamentals:
- How operating systems work
- Why algorithms matter
- What makes code maintainable
- How to analyze trade-offs

These fundamentals let me learn any new technology quickly because I understand the underlying principles.

**2. Real Projects**

Working on team projects with deadlines, requirements changes, and technical constraints prepared me for professional work better than any tutorial could.

**3. Learning to Learn**

The most valuable skill: learning how to learn independently. How to read documentation, debug systematically, and research solutions.

## First Professional Experience: Alemca

1.5 years at Alemca, a Montpellier startup building IoT remote management solutions. This is where theory met reality.

**What I Did**:
- Renovated the web application (Flask, Jinja templates)
- Architected data and file management poles
- Made technical decisions (InfluxDB, S3 storage, etc.)
- Designed APIs that other services depended on

**What I Learned**:
- Architectural decisions have long-term consequences
- Clean code isn't optional at scale
- Security must be built in from the start
- Technical debt trade-offs are constant
- Communication is as important as code quality

## The Pattern

Looking back, there's a clear pattern in my journey:

**Curiosity → Understanding → Building → Mastery**

1. **Curiosity**: Why does this work? How is this built?
2. **Understanding**: Research, learn fundamentals, go deep
3. **Building**: Create projects to solidify understanding
4. **Mastery**: Iterate, optimize, teach others

This pattern started in high school and continues today. Whether it's chess engines, distributed systems, or new technologies, the approach is the same.

## What Drives Me

**I love understanding how things work.** Not just "how to use X" but "how does X actually work under the hood?"

This curiosity led me to:
- Build a file system in Java to understand how file systems work
- Create a chess engine to understand search algorithms and optimization
- Set up a home lab to understand server infrastructure
- Study distributed systems through PawnPower

**I value quality over speed.** I'd rather spend time building something right than patch it forever. Technical debt is sometimes necessary, but it should be a conscious decision, not the default.

**I'm versatile.** I'm not just a "Java developer" - I'm someone who understands systems at multiple levels. Development, operations, architecture, security. The whole stack.

## Where This Led

Today, I'm a software engineer who:
- Primarily codes in Java but explores new technologies through projects
- Values clarity and quality in every line
- Thinks architecturally before writing code
- Can build and manage complex systems
- Learns constantly and deliberately

The path from Lodève to here wasn't linear, but every step built on the previous one. And the journey continues - there's always more to learn, more to build, more to understand.

## The Next Chapter

I'm looking for a project that challenges me technically. Where I can apply everything I've learned: clean code, thoughtful architecture, systematic analysis, pragmatic decision-making.

I love solving complex problems and building systems that are both powerful and maintainable. That's what I want to spend my time doing.

---

*"Before being a Java developer, I'm someone curious who researches. I learn every day and I love it. I'm passionate about understanding how everything around us works, and I love creating projects that help me discover how things function."*
